<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    // 树的术语
    // 空树： 就是等于0
    // 度：  节点的子节点个数
    //  叶节点： 就是没有子节点
    // 拥有同一个父亲的叫兄弟节点
    // 路径长度： 边的个数
    // 边： 父节点和子节点相连的线
    //节点的层次：  从根节点 横向往下数有多少层
    // 二叉数 ：如果一个标签只能有两个子节点
    // 二叉数五种状态： 空树  只有一个根节点  只有一个左节点  只有一个右节点  两个节点都有

    // n层最大节点
    let n = 1 //n 必须大于0
    2 * (n - 1) // 1 ,2, 4,  8,

    //深度  最大深度
    let k = 1
    2 * k - 1

    // 完全二叉树可以用数组
    // 非完全二叉树， 列表表示

    // 二叉 搜索树，二叉排序树  二叉排序树， 都是一个东西。
    //要求，
    //   左边树不能是空的  必须小于根节点，
    // 右边也不能是空树  必须大于根节点，
    // 左右树本身也都是二叉搜索树


    function BinarySearchTree() {
        // 根
        this.root = null
        //属性
        function Node(key) {
            this.key = key
            this.left = null
            this.right = null
        }

        // 方法
        //插入
        BinarySearchTree.prototype.insert = function (key) {
            // 创建根节点
            var newNode = new Node(key)

            //2 判断有没有根节点,如果没有 就把我们创建赋值给
            if (this.root === null) {
                this.root = newNode
            } else {
                this.insertNode(this.root, newNode)
            }


        }
        // 第一次

        //内部方法,递归循环内容
        BinarySearchTree.prototype.insertNode = function (node, newNode) {
            //向左查找
            if (newNode.key < node.key) {
                //向左查找分两种情况, 有可能左子节点 下面有内容，也有可能没有内容
                if (node.left == null) { //子节点没数据
                    node.left = newNode
                } else { //子节点有数据  递归调用
                    this.insertNode(node.left, newNode)
                }
            } else { //向右查找
                if (node.right == null) {
                    node.right = newNode
                } else {
                    this.insertNode(node.right, newNode)
                }
            }
        }

        //先序遍历  主要看什么时候处理根节点，选处理叫先序，中间处理叫中序，最后处理叫后序
        BinarySearchTree.prototype.preOrderTraversal = function (handler) {
            //从根节点进行遍历
            this.preOrderTraversalNode(this.root, handler)
        }
        // 先序遍历
        //第一次 执行根节点 11
        //第二次  node 5
        //第二次  node 7
        //第二次  node 3
        BinarySearchTree.prototype.preOrderTraversalNode = function (node, handler) {
            //说明不为null
            if (node != null) {
                //1处理我们经过的节点
                handler(node.key)

                //2处理我们经过的左子节点
                this.preOrderTraversalNode(node.left, handler)

                //3 处理右子节点
                this.preOrderTraversalNode(node.right, handler)
            }
        }


        //中序遍历功能
        BinarySearchTree.prototype.midOrderTraversal = function (handler) {
            this.midOrderTraversalNode(this.root, handler)
        }
        // 中序遍历
        BinarySearchTree.prototype.midOrderTraversalNode = function (node, handler) {
            if (node != null) {
                //1处理左子树
                this.midOrderTraversalNode(node.left, handler)
                //2处理我们经过的节点
                handler(node.key)
                //3 处理右子节点
                this.midOrderTraversalNode(node.right, handler)
            }
        }


        //后序遍历功能
        BinarySearchTree.prototype.postOrderTraversal = function (handler) {
            this.postOrderTraversalNode(this.root, handler)
        }
        // 中序遍历
        BinarySearchTree.prototype.postOrderTraversalNode = function (node, handler) {
            if (node != null) {
                //1处理左子树
                this.postOrderTraversalNode(node.left, handler)
                //2 处理右子节点
                this.postOrderTraversalNode(node.right, handler)
                //3处理我们经过的节点
                handler(node.key)
            }
        }
        //获取最大值
        BinarySearchTree.prototype.max = function () {
            var node = this.root
            var key = null
            while (node != null) {
                key = node.key
                node = node.right
            }
            return key
        }

        //获取最小值
        BinarySearchTree.prototype.min = function () {
            var node = this.root
            var key = null
            while (node != null) {
                key = node.key
                node = node.left
            }
            return key
        }

        //搜索特定值，如果存在就返回true
        BinarySearchTree.prototype.search = function (key) {
            var node = this.root;
            while (node != null) {
                if (key < node.key) {
                    node = node.left
                } else if (key > node.key) {
                    node = node.right
                } else {
                    return true
                }
            }
            return false
        }

        //删除操作 重点  先找到位置，在删除
        // 三种情况：
        //第一种是叶子节点  删除左边 要把 父亲的left设置null， 如果是右边就把父节点的right 设置null
        //第二种 删除有子节点的节点，需要把被删除的父亲指向 被删除的儿子
        // 第三种有两个 子节点的

        BinarySearchTree.prototype.remove = function (key) {
            //1 定义保存变量
            var current = this.root;
            //记录要删除的父节点
            var parent = this.root
            // 判断是左节点还是右节点
            var isLeftChild = true
            //2开始查找节点
            while (current.key != key) { //如果不等于就继续循环
                //等于它的父亲
                parent = current
                if (key < current.key) {
                    isLeftChild = true
                    current = current.left
                } else {
                    isLeftChild = false
                    current = current.right
                }
                // 没有找到节点
                if (current == null) return false
            }
            //2 找到了删除节点 或者是
            //2.1 删除的是叶子节点
            if (current.left == null && current.right == null) {
                if (current == this) { //根节点没有叶子
                    this.root = null
                }else if(isLeftChild){ //删除的是右边
                    parent.left =null  
                }else{
                    parent.right =null //删除的是左边
                }
            }
        }
    }

    let bst = new BinarySearchTree()
    bst.insert(11)
    bst.insert(7)
    bst.insert(15)
    bst.insert(5)
    bst.insert(3)
    bst.insert(9)
    bst.insert(8)
    bst.insert(10)
    bst.insert(13)
    bst.insert(12)
    bst.insert(14)
    bst.insert(20)
    bst.insert(18)
    bst.insert(25)
    bst.insert(6)
    console.log(bst)

    //测试 先序遍历
    var resultString = ""
    bst.preOrderTraversal(function (key) {
        resultString += key + " "
    })
    console.log(`先序遍历`, resultString)

    //测试 中序遍历 和排序一样
    var midString = ""
    bst.midOrderTraversal(function (key) {
        midString += key + " "
    })
    console.log(`中序遍历`, midString)


    //测试 后序遍历 
    var postString = ""
    bst.postOrderTraversal(function (key) {
        postString += key + " "
    })
    console.log(`后序遍历`, postString)

    //测试最大和最小值
    console.log(`测试最大和最小值`, bst.max(), bst.min())
    //存在返回true
    console.log(`查询`, bst.search(6))
</script>