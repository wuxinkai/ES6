<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    //单项列表只能能从头部遍历到尾部，
    //双向列表，既可以从头部遍历到尾部，又可以从尾部遍历到头部， 缺点：实现起来相对复杂


    function DoubyLinkedList() {
        //包含的属性
        this.head = null //头部
        this.tail = null //尾部 最后一个节点
        this.length = 0

        //内部类
        function Node(data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }

        // 方法封装
        //1 添加内容
        DoubyLinkedList.prototype.append = (data) => {
            //判断是不是第一个节点
            var newData = new Node(data)
            if (this.length == 0) { //是第一个节点
                this.head = newData
                this.tail = newData
            } else { //不是第一个节点
                newData.prev = this.tail
                this.tail.next = newData
                this.tail = newData
            }
            //添加让索引
            this.length += 1
        }
        // 2 转为tostring
        DoubyLinkedList.prototype.toString = function () {
            return this.backwardString()
        }
        // 3  从最后一个节点遍历到第一个节点 ，向前遍历循环 forwardString
        DoubyLinkedList.prototype.forwardString = function (Symbol = "") {
            // 先获取最后一个
            var current = this.tail
            var resultString = ""
            while (current) {
                resultString += current.data + `${Symbol}`
                current = current.prev //获取的是上一个，循环遍历的也是上一个
            }
            return resultString
        }
        // 4  从第一个节点遍历到最后一个节点，向后遍历循环 backwardString
        DoubyLinkedList.prototype.backwardString = function (Symbol = "") {
            var current = this.head;
            var resultString = ""
            while (current) {
                resultString += current.data + `${Symbol}`
                current = current.next //获取的是下一个，循环遍历的也是下一个
            }
            return resultString
        }

        //5 双向插入内容
        DoubyLinkedList.prototype.insert = function (position, data) {
            //越界判断
            if (position < 0 || position > this.length) return false
            //根据data创建新的节点
            var newData = new Node(data)

            //判断是否为空，如果为空， 第一个和最后一个都是新创建的这一项
            if (this.length == 0) {
                this.head = newData
                this.tail = newData
            } else { //说明里面已经有节点了
                if (position == 0) { //判断插入的地方是第一个位置
                    this.head.prev = newData; //this.head是上一个， 他的指向插入的这个
                    newData.next = this.head //新来的这个下一个， 指向 被移动的这个
                    this.head = newData // 插入的前一个指向 刚进来的这个
                } else if (position === this.length) { //判断插入的地方是最后一个位置
                    newData.prev = this.tail; // newData是插入进来的，  this.tail 上一个的指针
                    this.tail.next = newData //让上一个的item的 下一个指针指向，当前项
                    this.tail = newData //让最后一项的指针指向出入进来的这个
                } else { //插入到中间，
                    var current = this.head;
                    var index = 0;
                    while (index++ < position) { //遍历循环不断去查找
                        current = current.next
                    }
                    newData.next = current //插入(newData) 的向下指针，指向我们查找到的这一项
                    newData.prev = current.prev //newData.prev 指向原来， 指向current的
                    current.prev.next = newData // current.prev原本是指向最后一个的，他的prev是第四个，第四个的下一个就是我们插入的这项
                    current.prev = newData // current指向 我们新插入的
                }

            }
            this.length += 1
            return true
        }

        DoubyLinkedList.prototype.get = (position) => {
            //越界判断
            if (position < 0 || position >= this.length) return null
            //获取元素
            var current = this.head
            var index = 0;
            while (index++ < position) {
                current = current.next
            }
            return current.data
        }
        //6  indexof 传一个元素根据元素，返回当前索引。如果没有索引返回 -1
        DoubyLinkedList.prototype.indexOf = (data) => {
            var current = this.head;
            var index = 0
            while (current) {
                if (current.data === data) {
                    return index
                }
                current = current.next
                index += 1
            }
            return -1
        }
        //7 更新方法
        DoubyLinkedList.prototype.updata = (position, newData) => {
            //越界判断
            if (position < 0 || position >= this.length) return false
            let current = this.head;
            let index = 0
            //查找节点 找到替换
            if (index++ === position) {
                current = current.next
            }

            //找到我们需要的     
            current.data = newData
            return true
        }

        //8  删除
        DoubyLinkedList.prototype.removeAt = (position) => {
            //越界判断
            if (position < 0 || this.length <= position) return null
            //2 判断是否只有一个节点 ,有三种情况，一种是删除第一个， 二种是删除末尾，三是删除中间

            let current = this.head

            if (position == 1) {
                this.head = null
                this.tail = null
            } else {
                //判断删除的是否是第一个节点
                if (position === 0) {
                    this.head.next.prev = null; //让当前的 要删除的下一个的，指针不在指向 删除的这个元素
                    this.head = this.head.next //
                } else if (position === this.length - 1) { //这是最后一个节点
                    current = this.tail
                    this.tail.next = null
                    this.tail = this.tail.prev //让自己等于自己的前一个节点。 因为最后一个被删除了
                } else {
                    var index = 0;

                    while (index++ < position) {
                        current = current.next
                    }
                    current.prev.next = current.next
                    current.next.prev = current.prev
                }
            }
            this.length -= 1
            return current.data
        }

        //通过内容删除
        DoubyLinkedList.prototype.remove = (data) => {
            var index = this.indexOf(data);
            return this.removeAt(index)
        }
        //判断是否为空
        DoubyLinkedList.prototype.isEmpty = () => {
            return this.length == 0
        }
        //判断长度
        DoubyLinkedList.prototype.size = () => {
            return this.length
        }
        //获取第一个元素
        DoubyLinkedList.prototype.getHead = () => {
            return this.head.data
        }
        //获取最后元素
        DoubyLinkedList.prototype.getTail = () => {
            return this.tail.data
        }
    }

    let douby = new DoubyLinkedList()

    douby.append('第一个')
    douby.append('第二个')
    douby.append('第三个')
    douby.append('第四个')
    douby.append('最后一个')
    douby.insert(4, '我是插入进来的')
    douby.updata(1, '被更新后的第一个')
    douby.removeAt(2) //第三个被删除
    douby.remove('第四个') //第四个被删除
    console.log(douby)

    //转成字符串
    console.log(douby.toString())
    console.log(`获取的是`, douby.get(3))
    //测试 从前到后
    console.log(douby.backwardString(' , '))
    //从后到前
    console.log(douby.forwardString(' ~ '))
    //
    console.log(`获取索引`, douby.indexOf('第二个'))
</script>