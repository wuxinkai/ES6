<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

</body>

</html>
<script>
  //ES6允许把声明的变量直接赋值给对象，
  let name = "ES6";
  let skill = '变量值';
  var obj = {
    name,
    skill
  };
  console.log(`变量直接赋值给对象`, obj);

  //属性值赋值
  let key = 'skill';
  var obj2 = {
    [key]: '获取内容'
  }
  console.log(`属性值赋值`, obj2.skill);

  //自定义对象方法
  var obj3 = {
    add: function (a, b) {
      return a + b;
    }
  }
  console.log(`自定义对象方法`, obj3.add(1, 2)); //3

  //案例
  var sex = '男';
  var person = {
    name: 'momo',
    [sex]: false,
    ['get' + 'name']() {
      return this.name;
    }
  };
  console.log(`案例`, person.getname());
  console.log(`案例`, person[sex])

  //Object.is( )  对象的比较方法,以前进行对象值的比较
  var obj4 = {
    name: '自定义'
  };
  var obj5 = {
    name: '自定义'
  };
  console.log(`===`, obj4.name === obj5.name); //true
  console.log(`Object.is`, Object.is(obj4.name, obj5.name)); //true


  //区分=== 和 is方法的区别是什么
  console.log(`区分=== 和 is方法的区别`, +0 === -0); //true
  console.log(`区分=== 和 is方法的区别`, NaN === NaN); //false
  console.log(`区分=== 和 is方法的区别`, Object.is(+0, -0)); //false
  console.log(`区分=== 和 is方法的区别`, Object.is(NaN, NaN)); //true

  //Object.assign( )合并对象
  //如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性
  let a = {
    a: 'Object.assign'
  };
  let b = {
    b: '合并对象'
  };
  let c = {
    c: '成功'
  };
  let d = Object.assign(a, b, c)

  console.log(`Object.assign合并对象`, d);
  let school = {
    ...a,
    ...b,
    ...c
  }
  console.log('es7对象合并', school)



  //Object.setPrototypeOf(object,prototype) 用来设置一个对象的prototype对象

  var Cat = function (name) {
    this.name = name;
  };
  Cat.prototype.showname = function () {
    return this.name;
  };

  var Person = function () {};
  Person.prototype.dadoudou = function () {}

  var c1 = new Cat('momo');
  //获取
  //Object.getPrototypeOf(object) 用来获取一个对象的prototype对象
  console.log(`setPrototypeOf`, Object.getPrototypeOf(c1))

  //设置
  Object.setPrototypeOf(c1, Person.prototype)
  //获取
  //showname 被替换换成了dadoudou
  console.log(`setPrototypeOf`, Object.getPrototypeOf(c1))


  /*
		Object.assign(target [,source1 ... sourceN])
		将source对象的可枚举属性赋值到target对象上。
		注意：如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

	*/
  var obj1 = {};
  var obj2 = {
    name: 'zMouse'
  };
  var obj3 = {
    name: 'duoduo',
    age: 34
  }
  Object.assign(obj1, obj2, obj3);
  //name 相同
  console.log(`assign`, obj1)


  //如果指定的属性存在于对象上，则返回其属性描述符对象
  console.log(Object.getOwnPropertyDescriptor('123', 'length'))
  /*
 configurable: false   是否可配置
enumerable: false    是否可枚举
value: 3
writable: false  是否可修改
 */

 //Object.keys() 返回值是数组里面放着【里面放着所有可枚举的属性】
 console.log(`Object.keys`,Object.keys(obj)) //["name", "skill"]

 //Object.values()
 //Object.enrties()

</script>